diff --git a/eth/api_backend.go b/eth/api_backend.go
index 91f392f94..8e3fd6afa 100644
--- a/eth/api_backend.go
+++ b/eth/api_backend.go
@@ -38,8 +38,13 @@ import (
 
 // EthApiBackend implements ethapi.Backend for full nodes
 type EthApiBackend struct {
-	eth *Ethereum
-	gpo *gasprice.Oracle
+	eth           *Ethereum
+	gpo           *gasprice.Oracle
+	statusBackend *ethapi.StatusBackend
+}
+
+func (b *EthApiBackend) GetStatusBackend() *ethapi.StatusBackend {
+	return b.statusBackend
 }
 
 func (b *EthApiBackend) ChainConfig() *params.ChainConfig {
diff --git a/eth/backend.go b/eth/backend.go
index 1cd9e8fff..152cff699 100644
--- a/eth/backend.go
+++ b/eth/backend.go
@@ -37,7 +37,6 @@ import (
 	"github.com/ethereum/go-ethereum/core/vm"
 	"github.com/ethereum/go-ethereum/eth/downloader"
 	"github.com/ethereum/go-ethereum/eth/filters"
-	"github.com/ethereum/go-ethereum/eth/gasprice"
 	"github.com/ethereum/go-ethereum/ethdb"
 	"github.com/ethereum/go-ethereum/event"
 	"github.com/ethereum/go-ethereum/internal/ethapi"
@@ -169,12 +168,11 @@ func New(ctx *node.ServiceContext, config *Config) (*Ethereum, error) {
 	eth.miner = miner.New(eth, eth.chainConfig, eth.EventMux(), eth.engine)
 	eth.miner.SetExtra(makeExtraData(config.ExtraData))
 
-	eth.ApiBackend = &EthApiBackend{eth, nil}
+	eth.ApiBackend = &EthApiBackend{eth, nil, nil}
 	gpoParams := config.GPO
 	if gpoParams.Default == nil {
 		gpoParams.Default = config.GasPrice
 	}
-	eth.ApiBackend.gpo = gasprice.NewOracle(eth.ApiBackend, gpoParams)
 
 	return eth, nil
 }
diff --git a/internal/ethapi/api.go b/internal/ethapi/api.go
index 025f42617..c75505aca 100644
--- a/internal/ethapi/api.go
+++ b/internal/ethapi/api.go
@@ -34,6 +34,7 @@ import (
 	"github.com/ethereum/go-ethereum/core/types"
 	"github.com/ethereum/go-ethereum/core/vm"
 	"github.com/ethereum/go-ethereum/crypto"
+	"github.com/ethereum/go-ethereum/les/status"
 	"github.com/ethereum/go-ethereum/log"
 	"github.com/ethereum/go-ethereum/p2p"
 	"github.com/ethereum/go-ethereum/params"
@@ -178,15 +179,24 @@ func (s *PublicTxPoolAPI) Inspect() map[string]map[string]map[string]string {
 // It offers only methods that can retrieve accounts.
 type PublicAccountAPI struct {
 	am *accounts.Manager
+	b  Backend
 }
 
 // NewPublicAccountAPI creates a new PublicAccountAPI.
-func NewPublicAccountAPI(am *accounts.Manager) *PublicAccountAPI {
-	return &PublicAccountAPI{am: am}
+func NewPublicAccountAPI(b Backend) *PublicAccountAPI {
+	return &PublicAccountAPI{
+		am: b.AccountManager(),
+		b:  b,
+	}
 }
 
 // Accounts returns the collection of accounts this node manages
 func (s *PublicAccountAPI) Accounts() []common.Address {
+	backend := s.b.GetStatusBackend()
+	if backend != nil {
+		return backend.am.Accounts()
+	}
+
 	addresses := make([]common.Address, 0) // return [] instead of nil if empty
 	for _, wallet := range s.am.Wallets() {
 		for _, account := range wallet.Accounts() {
@@ -216,6 +226,11 @@ func NewPrivateAccountAPI(b Backend, nonceLock *AddrLocker) *PrivateAccountAPI {
 
 // ListAccounts will return a list of addresses for accounts this node manages.
 func (s *PrivateAccountAPI) ListAccounts() []common.Address {
+	backend := s.b.GetStatusBackend()
+	if backend != nil {
+		return backend.am.Accounts()
+	}
+
 	addresses := make([]common.Address, 0) // return [] instead of nil if empty
 	for _, wallet := range s.am.Wallets() {
 		for _, account := range wallet.Accounts() {
@@ -337,6 +352,31 @@ func (s *PrivateAccountAPI) LockAccount(addr common.Address) bool {
 // tries to sign it with the key associated with args.To. If the given passwd isn't
 // able to decrypt the key it fails.
 func (s *PrivateAccountAPI) SendTransaction(ctx context.Context, args SendTxArgs, passwd string) (common.Hash, error) {
+	backend := s.b.GetStatusBackend()
+	if backend != nil {
+		return backend.SendTransaction(ctx, status.SendTxArgs(args))
+	}
+
+	return common.Hash{}, ErrStatusBackendNotInited
+}
+
+// CompleteQueuedTransaction creates a transaction by unpacking queued transaction, signs it and submits to the
+// transaction pool.
+func (s *PublicTransactionPoolAPI) CompleteQueuedTransaction(ctx context.Context, args SendTxArgs, passphrase string) (common.Hash, error) {
+	// Set some sanity defaults and terminate on failure
+	if err := args.setDefaults(ctx, s.b); err != nil {
+		return common.Hash{}, err
+	}
+
+	// make sure that only account which created the tx can complete it
+	selectedAccountAddress := "0x0"
+	if address, ok := ctx.Value(status.SelectedAccountKey).(string); ok {
+		selectedAccountAddress = address
+	}
+	if args.From.Hex() != selectedAccountAddress {
+		log.Info("Failed to complete tx", "from", args.From.Hex(), "selected account", selectedAccountAddress)
+		return common.Hash{}, status.ErrInvalidCompleteTxSender
+	}
 	// Look up the wallet containing the requested signer
 	account := accounts.Account{Address: args.From}
 
@@ -1152,7 +1192,7 @@ func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args Sen
 	if config := s.b.ChainConfig(); config.IsEIP155(s.b.CurrentBlock().Number()) {
 		chainID = config.ChainId
 	}
-	signed, err := wallet.SignTx(account, tx, chainID)
+	signed, err := wallet.SignTxWithPassphrase(account, passphrase, tx, chainID)
 	if err != nil {
 		return common.Hash{}, err
 	}
diff --git a/internal/ethapi/backend.go b/internal/ethapi/backend.go
index 368fa4872..cac58dfc0 100644
--- a/internal/ethapi/backend.go
+++ b/internal/ethapi/backend.go
@@ -68,6 +68,8 @@ type Backend interface {
 
 	ChainConfig() *params.ChainConfig
 	CurrentBlock() *types.Block
+
+	GetStatusBackend() *StatusBackend
 }
 
 func GetAPIs(apiBackend Backend) []rpc.API {
@@ -105,7 +107,7 @@ func GetAPIs(apiBackend Backend) []rpc.API {
 		}, {
 			Namespace: "eth",
 			Version:   "1.0",
-			Service:   NewPublicAccountAPI(apiBackend.AccountManager()),
+			Service:   NewPublicAccountAPI(apiBackend),
 			Public:    true,
 		}, {
 			Namespace: "personal",
diff --git a/internal/ethapi/status_backend.go b/internal/ethapi/status_backend.go
new file mode 100644
index 000000000..c4e553cae
--- /dev/null
+++ b/internal/ethapi/status_backend.go
@@ -0,0 +1,88 @@
+package ethapi
+
+import (
+	"context"
+	"errors"
+	"math/big"
+
+	"github.com/ethereum/go-ethereum/common"
+	"github.com/ethereum/go-ethereum/common/hexutil"
+	"github.com/ethereum/go-ethereum/les/status"
+	"github.com/ethereum/go-ethereum/log"
+)
+
+// StatusBackend exposes Ethereum internals to support custom semantics in status-go bindings
+type StatusBackend struct {
+	eapi  *PublicEthereumAPI        // Wrapper around the Ethereum object to access metadata
+	bcapi *PublicBlockChainAPI      // Wrapper around the blockchain to access chain data
+	txapi *PublicTransactionPoolAPI // Wrapper around the transaction pool to access transaction data
+
+	am *status.AccountManager
+}
+
+var (
+	ErrStatusBackendNotInited = errors.New("StatusIM backend is not properly inited")
+)
+
+// NewStatusBackend creates a new backend using an existing Ethereum object.
+func NewStatusBackend(apiBackend Backend) *StatusBackend {
+	log.Info("StatusIM: backend service inited")
+	return &StatusBackend{
+		eapi:  NewPublicEthereumAPI(apiBackend),
+		bcapi: NewPublicBlockChainAPI(apiBackend),
+		txapi: NewPublicTransactionPoolAPI(apiBackend, new(AddrLocker)),
+		am:    status.NewAccountManager(apiBackend.AccountManager()),
+	}
+}
+
+// SetAccountsFilterHandler sets a callback that is triggered when account list is requested
+func (b *StatusBackend) SetAccountsFilterHandler(fn status.AccountsFilterHandler) {
+	b.am.SetAccountsFilterHandler(fn)
+}
+
+// AccountManager returns reference to account manager
+func (b *StatusBackend) AccountManager() *status.AccountManager {
+	return b.am
+}
+
+// SendTransaction wraps call to PublicTransactionPoolAPI.SendTransactionWithPassphrase
+func (b *StatusBackend) SendTransaction(ctx context.Context, args status.SendTxArgs, passphrase string) (common.Hash, error) {
+	if ctx == nil {
+		ctx = context.Background()
+	}
+
+	if estimatedGas, err := b.EstimateGas(ctx, args); err == nil {
+		if estimatedGas.ToInt().Cmp(big.NewInt(defaultGas)) == 1 { // gas > defaultGas
+			args.Gas = estimatedGas
+		}
+	}
+
+	return b.txapi.SendTransactionWithPassphrase(ctx, SendTxArgs(args), passphrase)
+}
+
+// EstimateGas uses underlying blockchain API to obtain gas for a given tx arguments
+func (b *StatusBackend) EstimateGas(ctx context.Context, args status.SendTxArgs) (*hexutil.Big, error) {
+	if args.Gas != nil {
+		return args.Gas, nil
+	}
+
+	var gasPrice hexutil.Big
+	if args.GasPrice != nil {
+		gasPrice = *args.GasPrice
+	}
+
+	var value hexutil.Big
+	if args.Value != nil {
+		value = *args.Value
+	}
+
+	callArgs := CallArgs{
+		From:     args.From,
+		To:       args.To,
+		GasPrice: gasPrice,
+		Value:    value,
+		Data:     args.Data,
+	}
+
+	return b.bcapi.EstimateGas(ctx, callArgs)
+}
diff --git a/les/api_backend.go b/les/api_backend.go
index 56f617a7d..b0ef4e81e 100644
--- a/les/api_backend.go
+++ b/les/api_backend.go
@@ -38,8 +38,13 @@ import (
 )
 
 type LesApiBackend struct {
-	eth *LightEthereum
-	gpo *gasprice.Oracle
+	eth           *LightEthereum
+	gpo           *gasprice.Oracle
+	statusBackend *ethapi.StatusBackend
+}
+
+func (b *LesApiBackend) GetStatusBackend() *ethapi.StatusBackend {
+	return b.statusBackend
 }
 
 func (b *LesApiBackend) ChainConfig() *params.ChainConfig {
diff --git a/les/backend.go b/les/backend.go
index 333df920e..4d46db57f 100644
--- a/les/backend.go
+++ b/les/backend.go
@@ -75,6 +75,8 @@ type LightEthereum struct {
 	netRPCService *ethapi.PublicNetAPI
 
 	wg sync.WaitGroup
+
+	StatusBackend *ethapi.StatusBackend
 }
 
 func New(ctx *node.ServiceContext, config *eth.Config) (*LightEthereum, error) {
@@ -126,12 +128,17 @@ func New(ctx *node.ServiceContext, config *eth.Config) (*LightEthereum, error) {
 	if leth.protocolManager, err = NewProtocolManager(leth.chainConfig, true, ClientProtocolVersions, config.NetworkId, leth.eventMux, leth.engine, leth.peers, leth.blockchain, nil, chainDb, leth.odr, leth.relay, quitSync, &leth.wg); err != nil {
 		return nil, err
 	}
-	leth.ApiBackend = &LesApiBackend{leth, nil}
+	leth.ApiBackend = &LesApiBackend{leth, nil, nil}
 	gpoParams := config.GPO
 	if gpoParams.Default == nil {
 		gpoParams.Default = config.GasPrice
 	}
 	leth.ApiBackend.gpo = gasprice.NewOracle(leth.ApiBackend, gpoParams)
+
+	// inject status-im backend
+	eth.ApiBackend.statusBackend = ethapi.NewStatusBackend(eth.ApiBackend)
+	eth.StatusBackend = eth.ApiBackend.statusBackend // alias
+
 	return leth, nil
 }
 
@@ -226,6 +233,7 @@ func (s *LightEthereum) Start(srvr *p2p.Server) error {
 	protocolVersion := ClientProtocolVersions[len(ClientProtocolVersions)-1]
 	s.serverPool.start(srvr, lesTopic(s.blockchain.Genesis().Hash(), protocolVersion))
 	s.protocolManager.Start()
+	s.StatusBackend.Start()
 	return nil
 }
 
@@ -252,5 +260,7 @@ func (s *LightEthereum) Stop() error {
 	s.chainDb.Close()
 	close(s.shutdownChan)
 
+	s.StatusBackend.Stop()
+
 	return nil
 }
diff --git a/les/status/accounts.go b/les/status/accounts.go
new file mode 100644
index 000000000..78bd2ad92
--- /dev/null
+++ b/les/status/accounts.go
@@ -0,0 +1,45 @@
+package status
+
+import (
+	"github.com/ethereum/go-ethereum/accounts"
+	"github.com/ethereum/go-ethereum/common"
+)
+
+// AccountManager abstracts both internal account manager and extra filter status backend requires
+type AccountManager struct {
+	am                    *accounts.Manager
+	accountsFilterHandler AccountsFilterHandler
+}
+
+// NewAccountManager creates a new AccountManager
+func NewAccountManager(am *accounts.Manager) *AccountManager {
+	return &AccountManager{
+		am: am,
+	}
+}
+
+// AccountsFilterHandler function to filter out accounts list
+type AccountsFilterHandler func([]common.Address) []common.Address
+
+// Accounts returns accounts' addresses of currently logged in user.
+// Since status supports HD keys, the following list is returned:
+// [addressCDK#1, addressCKD#2->Child1, addressCKD#2->Child2, .. addressCKD#2->ChildN]
+func (d *AccountManager) Accounts() []common.Address {
+	var addresses []common.Address
+	for _, wallet := range d.am.Wallets() {
+		for _, account := range wallet.Accounts() {
+			addresses = append(addresses, account.Address)
+		}
+	}
+
+	if d.accountsFilterHandler != nil {
+		return d.accountsFilterHandler(addresses)
+	}
+
+	return addresses
+}
+
+// SetAccountsFilterHandler sets filtering function for accounts list
+func (d *AccountManager) SetAccountsFilterHandler(fn AccountsFilterHandler) {
+	d.accountsFilterHandler = fn
+}
diff --git a/les/status/txqueue.go b/les/status/txqueue.go
new file mode 100644
index 000000000..efb7881eb
--- /dev/null
+++ b/les/status/txqueue.go
@@ -0,0 +1,240 @@
+package status
+
+import (
+	"errors"
+	"github.com/ethereum/go-ethereum/accounts/keystore"
+	"github.com/ethereum/go-ethereum/common"
+	"github.com/ethereum/go-ethereum/common/hexutil"
+	"github.com/ethereum/go-ethereum/log"
+	"golang.org/x/net/context"
+	"sync"
+)
+
+const (
+	DefaultTxQueueCap              = int(35) // how many items can be queued
+	DefaultTxSendQueueCap          = int(70) // how many items can be passed to sendTransaction() w/o blocking
+	DefaultTxSendCompletionTimeout = 300     // how many seconds to wait before returning result in sentTransaction()
+	SelectedAccountKey             = "selected_account"
+)
+
+var (
+	ErrQueuedTxIdNotFound      = errors.New("transaction hash not found")
+	ErrQueuedTxTimedOut        = errors.New("transaction sending timed out")
+	ErrQueuedTxDiscarded       = errors.New("transaction has been discarded")
+	ErrInvalidCompleteTxSender = errors.New("transaction can only be completed by the same account which created it")
+)
+
+// TxQueue is capped container that holds pending transactions
+type TxQueue struct {
+	transactions  map[QueuedTxId]*QueuedTx
+	mu            sync.RWMutex // to guard transactions map
+	evictableIds  chan QueuedTxId
+	enqueueTicker chan struct{}
+	incomingPool  chan *QueuedTx
+
+	// when this channel is closed, all queue channels processing must cease (incoming queue, processing queued items etc)
+	stopped      chan struct{}
+	stoppedGroup sync.WaitGroup // to make sure that all routines are stopped
+
+	// when items are enqueued notify subscriber
+	txEnqueueHandler EnqueuedTxHandler
+
+	// when tx is returned (either successfully or with error) notify subscriber
+	txReturnHandler EnqueuedTxReturnHandler
+}
+
+// QueuedTx holds enough information to complete the queued transaction.
+type QueuedTx struct {
+	Id      QueuedTxId
+	Hash    common.Hash
+	Context context.Context
+	Args    SendTxArgs
+	Done    chan struct{}
+	Discard chan struct{}
+	Err     error
+}
+
+type QueuedTxId string
+
+// EnqueuedTxHandler is a function that receives queued/pending transactions, when they get queued
+type EnqueuedTxHandler func(QueuedTx)
+
+// EnqueuedTxReturnHandler is a function that receives response when tx is complete (both on success and error)
+type EnqueuedTxReturnHandler func(queuedTx *QueuedTx, err error)
+
+// SendTxArgs represents the arguments to submit a new transaction into the transaction pool.
+type SendTxArgs struct {
+	From     common.Address  `json:"from"`
+	To       *common.Address `json:"to"`
+	Gas      *hexutil.Big    `json:"gas"`
+	GasPrice *hexutil.Big    `json:"gasPrice"`
+	Value    *hexutil.Big    `json:"value"`
+	Data     hexutil.Bytes   `json:"data"`
+	Nonce    *hexutil.Uint64 `json:"nonce"`
+}
+
+func NewTransactionQueue() *TxQueue {
+	log.Info("StatusIM: initializing transaction queue")
+	return &TxQueue{
+		transactions:  make(map[QueuedTxId]*QueuedTx),
+		evictableIds:  make(chan QueuedTxId, DefaultTxQueueCap), // will be used to evict in FIFO
+		enqueueTicker: make(chan struct{}),
+		incomingPool:  make(chan *QueuedTx, DefaultTxSendQueueCap),
+	}
+}
+
+func (q *TxQueue) Start() {
+	log.Info("StatusIM: starting transaction queue")
+
+	q.stopped = make(chan struct{})
+	q.stoppedGroup.Add(2)
+
+	go q.evictionLoop()
+	go q.enqueueLoop()
+}
+
+func (q *TxQueue) Stop() {
+	log.Info("StatusIM: stopping transaction queue")
+	close(q.stopped) // stops all processing loops (enqueue, eviction etc)
+	q.stoppedGroup.Wait()
+}
+
+func (q *TxQueue) evictionLoop() {
+	for {
+		select {
+		case <-q.enqueueTicker:
+			if len(q.transactions) >= (DefaultTxQueueCap - 1) { // eviction is required to accommodate another/last item
+				q.Remove(<-q.evictableIds)
+				q.enqueueTicker <- struct{}{} // in case we pulled already removed item
+			}
+		case <-q.stopped:
+			log.Info("StatusIM: transaction queue's eviction loop stopped")
+			q.stoppedGroup.Done()
+			return
+		}
+	}
+}
+
+func (q *TxQueue) enqueueLoop() {
+	// enqueue incoming transactions
+	for {
+		select {
+		case queuedTx := <-q.incomingPool:
+			log.Info("StatusIM: transaction enqueued", "txid", queuedTx.Id)
+			q.Enqueue(queuedTx)
+		case <-q.stopped:
+			log.Info("StatusIM: transaction queue's enqueue loop stopped")
+			q.stoppedGroup.Done()
+			return
+		}
+	}
+}
+
+// Reset is to be used in tests only, as it simply creates new transaction map, w/o any cleanup of the previous one
+func (q *TxQueue) Reset() {
+	q.mu.Lock()
+	defer q.mu.Unlock()
+
+	q.transactions = make(map[QueuedTxId]*QueuedTx)
+	q.evictableIds = make(chan QueuedTxId, DefaultTxQueueCap)
+}
+
+func (q *TxQueue) EnqueueAsync(tx *QueuedTx) error {
+	q.incomingPool <- tx
+
+	return nil
+}
+
+func (q *TxQueue) Enqueue(tx *QueuedTx) error {
+	if q.txEnqueueHandler == nil { //discard, until handler is provided
+		return nil
+	}
+
+	q.enqueueTicker <- struct{}{} // notify eviction loop that we are trying to insert new item
+	q.evictableIds <- tx.Id       // this will block when we hit DefaultTxQueueCap
+
+	q.mu.Lock()
+	q.transactions[tx.Id] = tx
+	q.mu.Unlock()
+
+	// notify handler
+	q.txEnqueueHandler(*tx)
+
+	return nil
+}
+
+func (q *TxQueue) Get(id QueuedTxId) (*QueuedTx, error) {
+	q.mu.RLock()
+	defer q.mu.RUnlock()
+
+	if tx, ok := q.transactions[id]; ok {
+		return tx, nil
+	}
+
+	return nil, ErrQueuedTxIdNotFound
+}
+
+func (q *TxQueue) Remove(id QueuedTxId) {
+	q.mu.Lock()
+	defer q.mu.Unlock()
+
+	delete(q.transactions, id)
+}
+
+func (q *TxQueue) Count() int {
+	q.mu.RLock()
+	defer q.mu.RUnlock()
+
+	return len(q.transactions)
+}
+
+func (q *TxQueue) Has(id QueuedTxId) bool {
+	q.mu.RLock()
+	defer q.mu.RUnlock()
+
+	_, ok := q.transactions[id]
+
+	return ok
+}
+
+func (q *TxQueue) SetEnqueueHandler(fn EnqueuedTxHandler) {
+	q.txEnqueueHandler = fn
+}
+
+func (q *TxQueue) SetTxReturnHandler(fn EnqueuedTxReturnHandler) {
+	q.txReturnHandler = fn
+}
+
+func (q *TxQueue) NotifyOnQueuedTxReturn(queuedTx *QueuedTx, err error) {
+	if q == nil {
+		return
+	}
+
+	// discard, if transaction is not found
+	if queuedTx == nil {
+		return
+	}
+
+	// on success, remove item from the queue and stop propagating
+	if err == nil {
+		q.Remove(queuedTx.Id)
+		return
+	}
+
+	// error occurred, send upward notification
+	if q.txReturnHandler == nil { // discard, until handler is provided
+		return
+	}
+
+	// remove from queue on any error (except for transient ones) and propagate
+	transientErrs := map[error]bool{
+		keystore.ErrDecrypt:        true, // wrong password
+		ErrInvalidCompleteTxSender: true, // completing tx create from another account
+	}
+	if !transientErrs[err] { // remove only on unrecoverable errors
+		q.Remove(queuedTx.Id)
+	}
+
+	// notify handler
+	q.txReturnHandler(queuedTx, err)
+}
